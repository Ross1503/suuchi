{
    "docs": [
        {
            "location": "/", 
            "text": "Suuchi\n\n\nToolkit to build distributed data systems.\n\n\nLibrary Dependency\n\n\nMaven\n\n\ndependency\n\n    \ngroupId\nin.ashwanthkumar\n/groupId\n\n    \nartifactId\nsuuchi-core\n/artifactId\n\n    \nversion\n${suuchi.version}\n/version\n\n\n/dependency\n\n\n\n\n\nDevelopment snapshots are available in \nSonatypes's snapshot repository\n.\n\n\nIf you are a developer looking to use Suuchi, head over to \nQuick Start\n guide to get started.\n\n\nRecipes\n\n\n\n\nDistributed InMemory Database\n\n\nDistributed RocksDB backed KV\n\n\n\n\nInternals\n\n\nWe try to document the internal workings of some core pieces of Suuchi for developers interested in contributing or understanding their systems better.\n\n\n\n\nPartitioner\n\n\nReplication\n\n\nRouter\n\n\n\n\nLicense\n\n\nhttps://www.apache.org/licenses/LICENSE-2.0", 
            "title": "Introduction"
        }, 
        {
            "location": "/#suuchi", 
            "text": "Toolkit to build distributed data systems.", 
            "title": "Suuchi"
        }, 
        {
            "location": "/#library-dependency", 
            "text": "", 
            "title": "Library Dependency"
        }, 
        {
            "location": "/#maven", 
            "text": "dependency \n     groupId in.ashwanthkumar /groupId \n     artifactId suuchi-core /artifactId \n     version ${suuchi.version} /version  /dependency   Development snapshots are available in  Sonatypes's snapshot repository .  If you are a developer looking to use Suuchi, head over to  Quick Start  guide to get started.", 
            "title": "Maven"
        }, 
        {
            "location": "/#recipes", 
            "text": "Distributed InMemory Database  Distributed RocksDB backed KV", 
            "title": "Recipes"
        }, 
        {
            "location": "/#internals", 
            "text": "We try to document the internal workings of some core pieces of Suuchi for developers interested in contributing or understanding their systems better.   Partitioner  Replication  Router", 
            "title": "Internals"
        }, 
        {
            "location": "/#license", 
            "text": "https://www.apache.org/licenses/LICENSE-2.0", 
            "title": "License"
        }, 
        {
            "location": "/quick-start/", 
            "text": "Quick Start\n\n\nTBD", 
            "title": "Quick Start"
        }, 
        {
            "location": "/quick-start/#quick-start", 
            "text": "TBD", 
            "title": "Quick Start"
        }, 
        {
            "location": "/internals/partitioner/", 
            "text": "Partitioner\n\n\nTBD", 
            "title": "Partitioner"
        }, 
        {
            "location": "/internals/partitioner/#partitioner", 
            "text": "TBD", 
            "title": "Partitioner"
        }, 
        {
            "location": "/internals/replication/", 
            "text": "Replication Internals\n\n\nSuuchi out of the box comes with \nSynchronous Sequential Replication\n during writes. It's fairly easy to build custom replicators.\n\n\nRefer \n#27\n and \n#23\n on how Replication is implemented.\n\n\nTypes\n\n\n\n\nSynchronous SequentialReplication (default available)\n\n\nSynchronous ParallelReplication - (\n#30\n)\n\n\nSynchronous ChainedReplication - (\n#31\n)", 
            "title": "Replication"
        }, 
        {
            "location": "/internals/replication/#replication-internals", 
            "text": "Suuchi out of the box comes with  Synchronous Sequential Replication  during writes. It's fairly easy to build custom replicators.  Refer  #27  and  #23  on how Replication is implemented.", 
            "title": "Replication Internals"
        }, 
        {
            "location": "/internals/replication/#types", 
            "text": "Synchronous SequentialReplication (default available)  Synchronous ParallelReplication - ( #30 )  Synchronous ChainedReplication - ( #31 )", 
            "title": "Types"
        }, 
        {
            "location": "/internals/router/", 
            "text": "HandleOrForward Router\n\n\nHandleOrForward Router is the entry point of a request in your Suuchi based application. It uses a \nRoutingStrategy\n implementation to decide which nodes in the cluster are eligible for handling the current request. It also takes care of forwarding the request to that particular node and returning the response back to the client.\n\n\nSince there isn't any \nSPOC\n (Single Point of Contact) in the system, any node in the cluster can handle or forward any request automatically. This makes the whole operations of the systems very easy. You can setup a load balancer as an entry point to your app\nbacked by all the nodes in the cluster.\n\n\nRefer \n#23\n, \n#11\n and \n#2\n on how HandleOrForward Router is implemented. TBD - Explain with pictures on how it works.\n\n\nRoutingStrategy\n\n\nRoutingStrategy forms the heart of HandleOrForward router. Out of the box Suuchi comes with the following routing strategies\n\n\n\n\nConsistentHashingRouting\n\n\n\n\nCustom Routers\n\n\nRoutingStrategy\n trait is defined as follows\n\n\ntrait RoutingStrategy {\n  /**\n   * Decides if the incoming message should be forwarded or handled by the current node.\n   *\n   * @tparam ReqT Type of the input Message\n   * @return  Some(MemberAddress) - if the request is meant to be forwarded\n   *          \np\n None - if the request can be handled by the current node\n   */\n  def route[ReqT]: PartialFunction[ReqT, Option[MemberAddress]]\n}\n\n\n\n\nAny implementations of that trait can be passed to HandleOrForward Router.\n\n\nNotes\n\n\n\n\nHandleOrForward Router is implemented internally as a ServerInterceptor. What this means is, when you're handling a streaming request every message that's sent in the stream goes through HandleOrForward backed by a RoutingStrategy to decide which nodes the request should go to.", 
            "title": "Router"
        }, 
        {
            "location": "/internals/router/#handleorforward-router", 
            "text": "HandleOrForward Router is the entry point of a request in your Suuchi based application. It uses a  RoutingStrategy  implementation to decide which nodes in the cluster are eligible for handling the current request. It also takes care of forwarding the request to that particular node and returning the response back to the client.  Since there isn't any  SPOC  (Single Point of Contact) in the system, any node in the cluster can handle or forward any request automatically. This makes the whole operations of the systems very easy. You can setup a load balancer as an entry point to your app\nbacked by all the nodes in the cluster.  Refer  #23 ,  #11  and  #2  on how HandleOrForward Router is implemented. TBD - Explain with pictures on how it works.", 
            "title": "HandleOrForward Router"
        }, 
        {
            "location": "/internals/router/#routingstrategy", 
            "text": "RoutingStrategy forms the heart of HandleOrForward router. Out of the box Suuchi comes with the following routing strategies   ConsistentHashingRouting", 
            "title": "RoutingStrategy"
        }, 
        {
            "location": "/internals/router/#custom-routers", 
            "text": "RoutingStrategy  trait is defined as follows  trait RoutingStrategy {\n  /**\n   * Decides if the incoming message should be forwarded or handled by the current node.\n   *\n   * @tparam ReqT Type of the input Message\n   * @return  Some(MemberAddress) - if the request is meant to be forwarded\n   *           p  None - if the request can be handled by the current node\n   */\n  def route[ReqT]: PartialFunction[ReqT, Option[MemberAddress]]\n}  Any implementations of that trait can be passed to HandleOrForward Router.", 
            "title": "Custom Routers"
        }, 
        {
            "location": "/internals/router/#notes", 
            "text": "HandleOrForward Router is implemented internally as a ServerInterceptor. What this means is, when you're handling a streaming request every message that's sent in the stream goes through HandleOrForward backed by a RoutingStrategy to decide which nodes the request should go to.", 
            "title": "Notes"
        }, 
        {
            "location": "/recipes/inmemorydb/", 
            "text": "Distributed InMemory Database\n\n\nFollowing code builds a consistent hashing based Get/Put requests backed by an ConcurrentHashMap.\n\n\npackage in.ashwanthkumar.suuchi.example\n\nimport in.ashwanthkumar.suuchi.router.ConsistentHashingRouting\nimport in.ashwanthkumar.suuchi.rpc.Server.whoami\nimport in.ashwanthkumar.suuchi.rpc.{Server, SuuchiPutService, SuuchiReadService}\nimport in.ashwanthkumar.suuchi.store.InMemoryStore\nimport io.grpc.netty.NettyServerBuilder\n\nobject ExampleApp extends App {\n  val routingStrategy = ConsistentHashingRouting(2, whoami(5051), whoami(5052), whoami(5053))\n\n  val store1 = new InMemoryStore\n  val server1 = Server(NettyServerBuilder.forPort(5051), whoami(5051))\n    .routeUsing(new SuuchiReadService(store1), routingStrategy)\n    .withReplication(new SuuchiPutService(store1), 2, routingStrategy)\n  server1.start()\n\n  val store2 = new InMemoryStore\n  val server2 = Server(NettyServerBuilder.forPort(5052), whoami(5052))\n    .routeUsing(new SuuchiReadService(store2), routingStrategy)\n    .withReplication(new SuuchiPutService(store2), 2, routingStrategy)\n  server2.start()\n\n  val store3 = new InMemoryStore\n  val server3 = Server(NettyServerBuilder.forPort(5053), whoami(5053))\n    .routeUsing(new SuuchiReadService(store3), routingStrategy)\n    .withReplication(new SuuchiPutService(store3), 2, routingStrategy)\n  server3.start()\n\n  server1.blockUntilShutdown()\n  server2.blockUntilShutdown()\n  server3.blockUntilShutdown()\n}\n\n\n\n\nLet's break down the above code step by step.\n\n\n\n\nConsistentHashingRouting\n is a \nRouting Strategy\n that does routing between all the nodes using a ConsistentHashRing underneath with default vnode factor of 3.\n\n\nNettyServerBuilder.forPort(5051)\n creates a NettyServer on \n5051\n port.\n\n\nserver.routeUsing()\n adds a new protobuf rpc using a custom routing strategy behind \nHandleOrForward\n router.\n\n\nserver.withReplication()\n adds a new protobuf rpc using the ReplicationRouter. By default it wraps both \nHandleOrForward\n and \nReplicator\n routers.\n\n\nserver1.start()\n starts the underlying gRPC server.\n\n\nserver1.blockUntilShutdown()\n waits until the server is stopped.", 
            "title": "Distributed In Memory Database"
        }, 
        {
            "location": "/recipes/inmemorydb/#distributed-inmemory-database", 
            "text": "Following code builds a consistent hashing based Get/Put requests backed by an ConcurrentHashMap.  package in.ashwanthkumar.suuchi.example\n\nimport in.ashwanthkumar.suuchi.router.ConsistentHashingRouting\nimport in.ashwanthkumar.suuchi.rpc.Server.whoami\nimport in.ashwanthkumar.suuchi.rpc.{Server, SuuchiPutService, SuuchiReadService}\nimport in.ashwanthkumar.suuchi.store.InMemoryStore\nimport io.grpc.netty.NettyServerBuilder\n\nobject ExampleApp extends App {\n  val routingStrategy = ConsistentHashingRouting(2, whoami(5051), whoami(5052), whoami(5053))\n\n  val store1 = new InMemoryStore\n  val server1 = Server(NettyServerBuilder.forPort(5051), whoami(5051))\n    .routeUsing(new SuuchiReadService(store1), routingStrategy)\n    .withReplication(new SuuchiPutService(store1), 2, routingStrategy)\n  server1.start()\n\n  val store2 = new InMemoryStore\n  val server2 = Server(NettyServerBuilder.forPort(5052), whoami(5052))\n    .routeUsing(new SuuchiReadService(store2), routingStrategy)\n    .withReplication(new SuuchiPutService(store2), 2, routingStrategy)\n  server2.start()\n\n  val store3 = new InMemoryStore\n  val server3 = Server(NettyServerBuilder.forPort(5053), whoami(5053))\n    .routeUsing(new SuuchiReadService(store3), routingStrategy)\n    .withReplication(new SuuchiPutService(store3), 2, routingStrategy)\n  server3.start()\n\n  server1.blockUntilShutdown()\n  server2.blockUntilShutdown()\n  server3.blockUntilShutdown()\n}  Let's break down the above code step by step.   ConsistentHashingRouting  is a  Routing Strategy  that does routing between all the nodes using a ConsistentHashRing underneath with default vnode factor of 3.  NettyServerBuilder.forPort(5051)  creates a NettyServer on  5051  port.  server.routeUsing()  adds a new protobuf rpc using a custom routing strategy behind  HandleOrForward  router.  server.withReplication()  adds a new protobuf rpc using the ReplicationRouter. By default it wraps both  HandleOrForward  and  Replicator  routers.  server1.start()  starts the underlying gRPC server.  server1.blockUntilShutdown()  waits until the server is stopped.", 
            "title": "Distributed InMemory Database"
        }, 
        {
            "location": "/recipes/rocksdb/", 
            "text": "Distributed RocksDB backed KV\n\n\nDependencies\n\n\ndependency\n\n    \ngroupId\nin.ashwanthkumar\n/groupId\n\n    \nartifactId\nsuuchi-core\n/artifactId\n\n    \nversion\n${suuchi.version}\n/version\n\n\n/dependency\n\n\ndependency\n\n    \ngroupId\nin.ashwanthkumar\n/groupId\n\n    \nartifactId\nsuuchi-rocksdb\n/artifactId\n\n    \nversion\n${suuchi.version}\n/version\n\n\n/dependency\n\n\n\n\n\nCode\n\n\nFollowing code builds a consistent hashing based Get/Put requests backed by \nRocksDB\n. It also does replication for Put requests to \nREPLICATION_COUNT\n number of nodes in the cluster.\n\n\npackage in.ashwanthkumar.suuchi.example\n\nimport java.nio.file.Files\n\nimport in.ashwanthkumar.suuchi.router.ConsistentHashingRouting\nimport in.ashwanthkumar.suuchi.rpc.Server._\nimport in.ashwanthkumar.suuchi.rpc.{Server, SuuchiPutService, SuuchiReadService}\nimport in.ashwanthkumar.suuchi.store.rocksdb.{RocksDbConfiguration, RocksDbStore}\nimport io.grpc.netty.NettyServerBuilder\n\nobject DistributedRocksDb extends App {\n  val REPLICATION_COUNT = 2\n  val routingStrategy = ConsistentHashingRouting(REPLICATION_COUNT, whoami(5051), whoami(5052))\n\n  val path1 = Files.createTempDirectory(\ndistributed-rocksdb\n).toFile\n  val store1 = new RocksDbStore(RocksDbConfiguration(path1.getAbsolutePath))\n  val server1 = Server(NettyServerBuilder.forPort(5051), whoami(5051))\n    .routeUsing(new SuuchiReadService(store1), routingStrategy)\n    .withReplication(new SuuchiPutService(store1), REPLICATION_COUNT, routingStrategy)\n  server1.start()\n\n  val path2 = Files.createTempDirectory(\ndistributed-rocksdb\n).toFile\n  val store2 = new RocksDbStore(RocksDbConfiguration(path2.getAbsolutePath))\n  val server2 = Server(NettyServerBuilder.forPort(5052), whoami(5052))\n    .routeUsing(new SuuchiReadService(store2), routingStrategy)\n    .withReplication(new SuuchiPutService(store2), REPLICATION_COUNT, routingStrategy)\n  server2.start()\n\n  server1.blockUntilShutdown()\n  server2.blockUntilShutdown()\n\n  /*\n    Optionally if want to delete the rocksdb directory\n      path1.delete()\n      path2.delete()\n  */\n}\n\n\n\n\nThis code is available as part of \nsuuchi-examples\n module in the repo.", 
            "title": "Distributed RocksDB Database"
        }, 
        {
            "location": "/recipes/rocksdb/#distributed-rocksdb-backed-kv", 
            "text": "", 
            "title": "Distributed RocksDB backed KV"
        }, 
        {
            "location": "/recipes/rocksdb/#dependencies", 
            "text": "dependency \n     groupId in.ashwanthkumar /groupId \n     artifactId suuchi-core /artifactId \n     version ${suuchi.version} /version  /dependency  dependency \n     groupId in.ashwanthkumar /groupId \n     artifactId suuchi-rocksdb /artifactId \n     version ${suuchi.version} /version  /dependency", 
            "title": "Dependencies"
        }, 
        {
            "location": "/recipes/rocksdb/#code", 
            "text": "Following code builds a consistent hashing based Get/Put requests backed by  RocksDB . It also does replication for Put requests to  REPLICATION_COUNT  number of nodes in the cluster.  package in.ashwanthkumar.suuchi.example\n\nimport java.nio.file.Files\n\nimport in.ashwanthkumar.suuchi.router.ConsistentHashingRouting\nimport in.ashwanthkumar.suuchi.rpc.Server._\nimport in.ashwanthkumar.suuchi.rpc.{Server, SuuchiPutService, SuuchiReadService}\nimport in.ashwanthkumar.suuchi.store.rocksdb.{RocksDbConfiguration, RocksDbStore}\nimport io.grpc.netty.NettyServerBuilder\n\nobject DistributedRocksDb extends App {\n  val REPLICATION_COUNT = 2\n  val routingStrategy = ConsistentHashingRouting(REPLICATION_COUNT, whoami(5051), whoami(5052))\n\n  val path1 = Files.createTempDirectory( distributed-rocksdb ).toFile\n  val store1 = new RocksDbStore(RocksDbConfiguration(path1.getAbsolutePath))\n  val server1 = Server(NettyServerBuilder.forPort(5051), whoami(5051))\n    .routeUsing(new SuuchiReadService(store1), routingStrategy)\n    .withReplication(new SuuchiPutService(store1), REPLICATION_COUNT, routingStrategy)\n  server1.start()\n\n  val path2 = Files.createTempDirectory( distributed-rocksdb ).toFile\n  val store2 = new RocksDbStore(RocksDbConfiguration(path2.getAbsolutePath))\n  val server2 = Server(NettyServerBuilder.forPort(5052), whoami(5052))\n    .routeUsing(new SuuchiReadService(store2), routingStrategy)\n    .withReplication(new SuuchiPutService(store2), REPLICATION_COUNT, routingStrategy)\n  server2.start()\n\n  server1.blockUntilShutdown()\n  server2.blockUntilShutdown()\n\n  /*\n    Optionally if want to delete the rocksdb directory\n      path1.delete()\n      path2.delete()\n  */\n}  This code is available as part of  suuchi-examples  module in the repo.", 
            "title": "Code"
        }
    ]
}